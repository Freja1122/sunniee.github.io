title: 配置管理
---

Annuuser

<!-- more -->

### 考点

##### 在软件开发过程中软件配置管理的作用

对某项目的Project_Rep目录下程序创建了一个标签（tag_test），根据标签对Project_Rep下的程序进行发布，changebalance.java程序进行修改，修改前的版本号为1.5 修改后的版本号为1.6.要求修改后的Project_Rep下的程序必须以tag_test这个标签进行再发布

```
git checkout tag_test #切换到tag-test标签
git branch v1.6 #创建新的分支
git tag -d tag_test #删除标签tag-test
git add . #添加当前内容到缓存
git commit -m "v1.6 change" #提交缓存中的内容
git tag tag_test #创建tag-test标签
git checkout master #切换到master分支
git merge v1.6 #合并v1.6分支
git push #推送到远端
git archive --format=zip --output=tag_test.zip tag_test
```



### 知识点

#### 初始化版本库

通过`git init`命令把这个目录变成Git可以管理的仓库

```
cd $项目目录
git init
```

目录下多了一个`.git`的目录，这个目录是Git来跟踪管理版本库的

#### 上传项目

将客户端的目录加入服务器作为一个项目，即一个baseline

```
git add -A #将目录下所有内容提交到暂存区
git commit -m "Initial commit." #将暂存区中的内容提交到仓库
git push origin master #提交代码到服务器上，两个参数，远端仓库的名字，以及分支的名字
```

#### 拉取项目

将指定仓库中的一个项目代码取到本地的工作目录下。

```
#拉取新的仓库
git clone #仓库网址
```

```
#拉取已有仓库的最新代码
git pull origin master
```

#### diff命令 

将你工作的源代码文件与仓库中的版本进行比较，发现差异。

```
git diff #查看本地文件和最新文件的差别
git diff [commit-from]..[commit-to] #查看指定两次提交的差别
```

先通过下面命令查看提交的版本的编号

```
$ git log
 
commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
Author: Tutorialzine
Date:   Mon May 30 17:15:28 2016 +0300
 
    New feature complete
 
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date:   Mon May 30 16:30:04 2016 +0300
 
    Added content to hello.txt
 
commit 09bd8cc171d7084e78e4d118a2346b7487dca059
Author: Tutorialzine
Date:   Sat May 28 17:52:14 2016 +0300
 
    Initial commit

```

#### 查看状态

```
git status
```

#### 撤销

```
git checkout 09bd8cc1 hello.txt #需要指定回滚到哪个提交，以及文件的全路径。
git reset --hard HEAD #撤销工作目录中所有未提交文件的修改内容
git checkout HEAD <file> #撤销指定的未提交文件中修改的内容
git revert <commit> #撤销指定的提交
```



### 版本标签和版本分支

##### 版本标签（tag）

```
git push origin tag Release_1_0 #创建标签并推送到远程
git tag tag_test #创建标签
git tag -l #查看标签
git show Release_1_0 #查看有关标签的更多详细信息
git tag -d Release_1_0 #删除标签
```

   例子：通过WinCVS展示版本标签
标签的设定
   [Du_cloud@linux test]$ cvs tag rel_1_0_1 test.c

注意：很少给单个文件设标签。
给目录下所有文件贴标签：
[Du_cloud@linux test]$ cvs tag baseline_1
标签的删除、重命名和移动
删除：
[Du_cloud@linux test]$ cvs tag –d baseline_1
重命名：
[Du_cloud@linux test]$ cvs tag –r baseline_1 baseline_2
[Du_cloud@linux test]$ cvs tag –d baseline_1
移动：
**[Du_cloud@linux test]$ cvs tag –r 1.6 –F baseline_1 test.c**
**我们将test.c的标签从旧版本**

```
[Du_cloud@linux test]$ cvs tag –r 1.6 –F baseline_1 test.c

我们将test.c的标签从旧版本

```

1.5移到新版本1.6上。

标签的命名
baseline_1-20030623
Release-20030522
Nightly-20030321
等。





标签的查看
   [Du_cloud@linux test]$ cvs status –v test.c
   [Du_cloud@linux test]$ cvs status –v
确定标签要贴的位置
   [Du_cloud@linux test]$ cvs tag –c baseline_1
贴标签时注意不要遗忘已经修改但没有提交的文件。
按约定贴标签（仓库中直接给模块加标签）
   按日期贴标签(下例是将模块test的所有文件在20030624号0时0分前提交的最后一个版本贴上标签：
   [Du_cloud@linux test]$ cvs rtag –D 20030624  nightly_20030624 test
   按版本号、已经有的标签贴新标签
   [Du_cloud@linux test]$ cvs rtag –r nightly_20030624(老tag） rel_2_1 test(贴新标签但test下新加程序不挂到标签上)

    [Du_cloud@linux test]$ cvs rtag –f nightly_20030624 test(将test下新加的程序的最新版本强制的挂到nightly_20030624上)
   [Du_cloud@linux test]$ cvs rtag –r 1.5 rel_2_1 test
   [Du_cloud@linux test]$ cvs rtag –f 1.5 rel_2_1 test
 附着性标签
   1)引起附着性标签的命令有：   





cvs update –r tag(标签号）
cvs update –D date（更新到不晚于date的最新版本）
cvs update –r x.y（版本号） test.c
cvs checkout –r tag(标签号）
cvs checkout –D date （date之前最近的版本）
cvs checkout –r x.y test.c
2)附着性标签在版本分支中的使用：保持版本分支号与标签有直接的关系，也就是标签附着在分支号上。
3)保持某些文件的不改动：
只要对几个文件执行了cvs update –r 命令，如：cvs update –r 1.28 ax.c则版本1.28就会成为附着性标签，以后执行cvs update 命令时这个文件不会更新，直到解除附着性为止。
另外，还有1）中的命令情况相同。
4）解除附着性标签：
[Du_cloud@linux test]$ cvs update –A test.c
该命令解除附着性标签，将checkout主干的最新版本并放本地。



1.6.3 如何获得某个特定的版本
根据版本号码或版本标签获得
 [Du_cloud@linux test]$ cvs update –r 1.1 test.c
  获得某一版本标签的整个软件的源代码：
 [Du_cloud@linux test]$ cvs checkout –r baseline_1 test
或者跳转到某个版本标签的版本（已经有工作拷贝的情况下）
[Du_cloud@linux test]$ cvs update –r baseline_1
根据时间获得特定版本（更新到不晚于date的最新版本）
 [Du_cloud@linux test]$ cvs update –D “2002-05-08”
 [Du_cloud@linux test]$ cvs update –D “2002-05-08 23:59:59”
[Du_cloud@linux test]$ cvs update –D “2002-05-09”
[Du_cloud@linux test]$ cvs update –D “2002-05-08 23:59:59 GMT”（让用户使用GMT时间）
如果要取回旧版本修改，而不是基于最新版本，修改后提交形成最新版本，方法有三：
1）逐个文件处理：
[Du_cloud@linux test]$ cvs update –p –D “2003-05-18’ test.c >test.c





方法二：一次性处理所有文件
[Du_cloud@linux test]$ cvs update –A
[Du_cloud@linux test]$ cvs export –D “2003-05-18” test
[Du_cloud@linux test]$ cp –r test /home/du_cloud
*将test.c的baseline_1标签移动从旧版本1.5到新版本1.6上：
cvs tag –r 1.6 –F baseline_1 test.c
1.6.4 版本分支
[Du_cloud@linux test]$ cvs co –d test_brh –r base_1 test
把项目里base_1标签的程序checkout出来 放到diractory新建的那个目录下
[Du_cloud@linux test_brh]$ cvs tag –b base_1_brh  创建分支
[Du_cloud@linux test_brh]$ cvs up –r base_1_brh(可以在分支中修改程序如：test.c）
[Du_cloud@linux test_brh]$ cvs ci –m “fixed bug no 111” test.c(提交到分支上）
[Du_cloud@linux test]$ cvs up –j base_1_brh(join分支版本合并到主干版本中）
[Du_cloud@linux test]$ cvs ci –m “merged from branch:base_1_brh”





Cvs输出（export)---发布代码(去出没有CVS痕迹的代码）
cvs export –r rel_1（主干上tag号） –d test_release1 test
cvs export –r brh_tag_brh(分支名称) –d shanghai_release test
[Du_cloud@linux test]$ tar –cvf test_release1.tar test_release1
[Du_cloud@linux test]$ gzip test_release1.tar

1.6.5  cvs与二进制文件
重要的二进制文件也需要进行版本管理。如：web应用的大量图片、控件、动态连接库、unix不同操作系统下的编译器、函数库等等。
CVS在处理文本类型的文件，包括各种源代码文件、HTML、XML文件等。CVS对文本类型的文件进行版本管理时，会对文件做一些秘密的处理，在客户端和UNIX仓库之间，CVS会自动进行回车、换行替换和关键字扩展处理。





CVS对二进制文件管理的不好，和ClearCase相比，ClearCase具有文件类型，可以进行二进制文件的比较，但是ClearCase也要尽量避免二进制文件的分支和合并。CVS无法进行二进制文件的合并和分支，不过在实际应用中二进制文件的合并和分支是没意义的。
CVS对二进制文件的管理和保存：
   1）在CVS系统中保存二进制文件，应该使用“-kb”选项来禁止CVS对文件进行回车、换行替换和关键字扩展的加工。这个选项只需要在cvs add 命令中使用，本选项是一个附着性选项（如果没有附着性每次执行cvs命令时都需要这个选项）。
   如：cvs add –kb binfile
   cvs commit –m “added binfile” binfile
   注意：二进制文件是原封不动的保存在仓库中，不能按照增量方式保存两个版本的差异，而是累加。
   2）恢复二进制版本，如果忘记使用“-kb”选项，添加了二进制文件并提交了仓库，库在UNIX/Linux平台上可以通过以下命令恢复：
   cvs admin –kb binfile（反扩展）
   cvs update –A binfile（工作拷贝中的文件恢复二进制）
   如果库在windows平台上只能手工处理。
CVS识别二进制文件:cvs中使用一种简单的技术来辨别二进制文件—根据扩展名。但需要进行配置，配置文件在服务器的/cvsap/src/master/CVSROOT



目录下的文件cvswrappers。首先执行：
cvs co /cvsap/src/master/CVSROOT/cvswrappers 
打开该文件，如在该文件的末尾加：
*.gif –k ‘-b’
*.jpg –k ‘-b’
*.bmp –k ‘-b’
*.mpp –k ‘-b’
*.xls –k ‘-b’
*.ppt –k ‘-b’
再执行：
cvs ci –m “add 7 binary file types” /cvsap/src/master/CVSROOT/cvswrappers
如果提交成功，那么以后对上述扩展名的二进制文件入库等处理不用再添加“-kb”选项了。
9.6.6 cvs仓库的备份和移动
在备份时cvs仓库不能处于接受用户命令状态，有两种方法做到这一点：
1）禁止任何用户使用cvs，保证所有之前的命令执行完备。



2）杀掉inetd/xinetd 超级服务进程。
之后，可以用一些备份工具或来进行备份。
仓库的移动，可执行两条命令：
tar –cvf  cvsrepository.tar /cvsap/src/master
gzip cvsrepository.tar
这样这个仓库已经在包cvsrepository.tar.gz中了。 
1.6.7 几个高级命令的介绍
1）annotate显示每个文件每一行的最近一次修改是哪个用户在什么时候进行的。输出的每一行对应文件中的每一行，如：
   cvs annotate test.c
   cvs annotate –r 1.1 test.c
   cvs annotate –D “yesterday” test.c（昨天之前最近的版本）
   cvs annotate –r baseline_1_patch test.c
   注意：不使用版本选项在分支上执行annotate命令时，输出的结果将是主干版本上的内容。
2）cvs仓库的历史记录命令history。如：
   cvs history –e
报告所有的历史记录。有关该命令的更多选项和操作代码含义参阅附录。



3）在提交之后改变日志信息。Admin命令应用于各种管理任务—特别是仓库中RCS文件的管理，如改变文件的关键字模式（在二进制一节中已经提及）和修改文件提交后的日志信息等。如用户提交后对日志不满意或领导要求重写：
   cvs admin –m1.2:“add main() function just for testing” test.c
   在“-m”和参数之间，以及冒号的前后都没有空格。共享日志需单独进行。
4)关键字的扩展。经常在源代码前加一部分代码的说明信息，可能包括版权信息、程序模块名、开发及修改日期、开发者及版本号自动扩展标识等。如:$Revision$,$Author$,$Date$,$Id$,$Source$(书127页）等，如在C/C++中：
   /*

    * $Revision$
    * Copyright © Sse, All Rights Reserved.
    */



注意：$Log$建议不要使用。Cvs扩展过的关键字随源文件更新为新版本，这些关键字的扩展的内容也一起更新，例外的识$Log$。
5）清除工作拷贝。 
   cvs release –d test
为什么不直接将工作目录下的文件直接删除呢？一是确保修改的文件都已经提交；二是让其他开发人员知道本工作目录已经不工作了。
1.6.8 Nightly Build技术的简单介绍
1）Nightly Build的概念
2）Nightly Build的管理机制
3）CVS进行Nightly Build